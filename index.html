<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Realistic Golden Universe - Explode Effect</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #000000; color: white; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #webcam-feed { position: absolute; bottom: 20px; left: 20px; width: 160px; height: 120px; border-radius: 10px; border: 2px solid #00ffff; z-index: 2; transform: scaleX(-1); object-fit: cover; opacity: 0.4; }
        #ui-layer { position: absolute; top: 20px; left: 20px; z-index: 3; pointer-events: none; }
        .instruction-card { background: rgba(0, 10, 20, 0.85); backdrop-filter: blur(8px); padding: 15px; border-radius: 12px; border: 1px solid rgba(0, 255, 255, 0.2); max-width: 300px; pointer-events: auto; }
        .status-dot { height: 10px; width: 10px; border-radius: 50%; display: inline-block; margin-right: 8px; }
        .status-active { background-color: #00ffff; box-shadow: 0 0 10px #00ffff; }
        .status-loading { background-color: #ffa500; }
        .gesture-icon { font-size: 1.2rem; width: 30px; display: inline-block; text-align: center; }
    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div class="instruction-card shadow-lg shadow-cyan-500/10">
            <h1 class="text-xl font-bold text-cyan-400 mb-2 tracking-wider">STAR CORE üí†</h1>
            <div id="loading-msg" class="text-sm text-gray-400 mb-2">
                <span class="status-dot status-loading" id="status-dot"></span>
                <span id="status-text">ƒêang kh·ªüi t·∫°o AI...</span>
            </div>
            
            <div class="space-y-2 text-sm text-cyan-100 mt-4 border-t border-cyan-900 pt-3">
                <div class="flex items-center">
                    <span class="gesture-icon">‚òùÔ∏è</span>
                    <span><strong>Ch·ªâ tr·ªè:</strong> N·ªï tung h·∫°t (Explode)</span>
                </div>
                <div class="flex items-center">
                    <span class="gesture-icon">‚úä</span>
                    <span><strong>N·∫Øm tay:</strong> Xoay & Thu h·ªìi h·∫°t</span>
                </div>
                <div class="flex items-center">
                    <span class="gesture-icon">‚úåÔ∏è</span>
                    <span><strong>2 Ng√≥n:</strong> Thu ph√≥ng (Zoom)</span>
                </div>
            </div>

            <div class="mt-4">
                <p class="text-xs text-cyan-600 font-mono">DEBUG:</p>
                <p id="debug-text" class="text-xs text-gray-500 font-mono">ƒêang qu√©t tay...</p>
            </div>
        </div>
    </div>

    <video id="webcam-feed" autoplay playsinline muted></video>

    <script>
        // --- C·∫§U H√åNH THREE.JS ---
        const container = document.getElementById('canvas-container');
        const debugText = document.getElementById('debug-text');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 8;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        const universeGroup = new THREE.Group();
        scene.add(universeGroup);

        const centralSystem = new THREE.Group();
        universeGroup.add(centralSystem);

        // --- T·∫†O TEXTURE H·∫†T ---
        const getSharpTexture = () => {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.3, 'rgba(255,255,255,0.4)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            const tex = new THREE.Texture(canvas);
            tex.needsUpdate = true;
            return tex;
        };
        const sharpTexture = getSharpTexture();

        // --- 1. H·∫†T B·ªÄ M·∫∂T (C√ì KH·∫¢ NƒÇNG N·ªî) ---
        const surfaceParticleCount = 8000;
        const surfGeo = new THREE.BufferGeometry();
        const surfPos = new Float32Array(surfaceParticleCount * 3);
        const originalPositions = new Float32Array(surfaceParticleCount * 3);
        const surfCols = new Float32Array(surfaceParticleCount * 3);

        for (let i = 0; i < surfaceParticleCount; i++) {
            const r = 1.9 + Math.random() * 0.4; 
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);

            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);

            surfPos[i * 3] = x; surfPos[i * 3 + 1] = y; surfPos[i * 3 + 2] = z;
            originalPositions[i * 3] = x; originalPositions[i * 3 + 1] = y; originalPositions[i * 3 + 2] = z;

            const col = new THREE.Color().setHSL(0.1 + Math.random() * 0.1, 1.0, 0.5);
            surfCols[i * 3] = col.r; surfCols[i * 3 + 1] = col.g; surfCols[i * 3 + 2] = col.b;
        }

        surfGeo.setAttribute('position', new THREE.BufferAttribute(surfPos, 3));
        surfGeo.setAttribute('color', new THREE.BufferAttribute(surfCols, 3));
        
        const planetSurface = new THREE.Points(surfGeo, new THREE.PointsMaterial({ 
            size: 0.07, vertexColors: true, map: sharpTexture, blending: THREE.AdditiveBlending, transparent: true, opacity: 0.8, depthWrite: false 
        }));
        centralSystem.add(planetSurface);

        // --- 2. L√ïI ---
        const blueCore = new THREE.Sprite(new THREE.SpriteMaterial({ color: 0x00ffff, blending: THREE.AdditiveBlending }));
        blueCore.scale.set(3, 3, 3);
        centralSystem.add(blueCore);

        // --- 3. V√íNG NH·∫™N ---
        const createRing = (innerR, outerR, count, color) => {
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(count * 3);
            for(let i=0; i<count; i++) {
                const r = innerR + Math.random() * (outerR - innerR);
                const theta = Math.random() * Math.PI * 2;
                pos[i*3] = r * Math.cos(theta);
                pos[i*3+1] = (Math.random()-0.5)*0.1;
                pos[i*3+2] = r * Math.sin(theta);
            }
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            return new THREE.Points(geo, new THREE.PointsMaterial({ size: 0.05, color: color, map: sharpTexture, blending: THREE.AdditiveBlending, transparent: true, opacity: 0.5 }));
        };
        centralSystem.add(createRing(3.5, 5.5, 8000, 0xffaa00));

        // --- LOGIC ƒêI·ªÄU KHI·ªÇN ---
        let state = {
            targetQuaternion: new THREE.Quaternion(),
            targetZoom: 8,
            explodeFactor: 0,
            targetExplode: 0,
            prevHandX: 0, prevHandY: 0
        };

        function onResults(results) {
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                state.targetExplode = 0; 
                return;
            }
            const lm = results.multiHandLandmarks[0];
            const hX = 1 - lm[9].x; const hY = lm[9].y;

            const isFolded = (tip, pip) => Math.hypot(lm[tip].x-lm[0].x, lm[tip].y-lm[0].y) < Math.hypot(lm[pip].x-lm[0].x, lm[pip].y-lm[0].y);
            const indexF = isFolded(8,6);
            const middleF = isFolded(12,10);
            const ringF = isFolded(16,14);
            const pinkyF = isFolded(20,18);

            if (!indexF && middleF && ringF && pinkyF) {
                state.targetExplode = 1; // N·ªï
                debugText.innerText = "‚òùÔ∏è EXPLODING";
            } else if (indexF && middleF && ringF && pinkyF) {
                state.targetExplode = 0; // N·∫Øm tay xoay
                const dX = hX - state.prevHandX;
                const dY = hY - state.prevHandY;
                const qY = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), dX * 5);
                const qX = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), dY * 5);
                state.targetQuaternion.premultiply(qY).premultiply(qX);
            } else {
                state.targetExplode = 0;
            }
            state.prevHandX = hX; state.prevHandY = hY;
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        hands.onResults(onResults);

        new Camera(document.getElementById('webcam-feed'), {
            onFrame: async () => await hands.send({image: document.getElementById('webcam-feed')}),
            width: 320, height: 240
        }).start().then(() => {
            document.getElementById('status-text').innerText = "H·ªá th·ªëng Online";
            document.getElementById('status-dot').className = "status-dot status-active";
        });

        // --- V√íNG L·∫∂P ANIMATION ---
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.02;

            // 1. C·∫≠p nh·∫≠t Explode Factor
            state.explodeFactor += (state.targetExplode - state.explodeFactor) * 0.08;
            
            // 2. Di chuy·ªÉn c√°c h·∫°t b·ªÅ m·∫∑t
            const posAttr = planetSurface.geometry.attributes.position;
            for (let i = 0; i < surfaceParticleCount; i++) {
                const i3 = i * 3;
                const ox = originalPositions[i3];
                const oy = originalPositions[i3+1];
                const oz = originalPositions[i3+2];

                // V·ªã tr√≠ ƒë√≠ch khi n·ªï (bay xa g·∫•p 4 l·∫ßn k√®m ch√∫t nhi·ªÖu s√≥ng)
                const tx = ox * 4 + Math.sin(time + i) * 0.3;
                const ty = oy * 4 + Math.cos(time + i) * 0.3;
                const tz = oz * 4;

                // N·ªôi suy t·ª´ g·ªëc ƒë·∫øn ƒë√≠ch
                posAttr.array[i3] = ox + (tx - ox) * state.explodeFactor;
                posAttr.array[i3+1] = oy + (ty - oy) * state.explodeFactor;
                posAttr.array[i3+2] = oz + (tz - oz) * state.explodeFactor;
            }
            posAttr.needsUpdate = true;

            // 3. Xoay v√† Hi·ªáu ·ª©ng l√µi
            universeGroup.quaternion.slerp(state.targetQuaternion, 0.1);
            blueCore.scale.set(2 + Math.sin(time*3)*0.5, 2 + Math.sin(time*3)*0.5, 1);
            
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
