<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Golden Universe - Explode Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: white; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #webcam-feed { position: absolute; bottom: 20px; left: 20px; width: 180px; height: 135px; border-radius: 12px; border: 2px solid #00ffff; z-index: 10; transform: scaleX(-1); object-fit: cover; opacity: 0.7; box-shadow: 0 0 15px rgba(0, 255, 255, 0.5); }
        
        #ui-layer { position: absolute; top: 20px; left: 20px; z-index: 20; pointer-events: none; }
        .glass-card { background: rgba(0, 10, 20, 0.8); backdrop-filter: blur(10px); padding: 20px; border-radius: 15px; border: 1px solid rgba(0, 255, 255, 0.2); width: 300px; pointer-events: auto; }
        
        .status-dot { height: 10px; width: 10px; border-radius: 50%; display: inline-block; margin-right: 8px; }
        .active { background: #00ffff; box-shadow: 0 0 10px #00ffff; }
        .loading { background: #ffa500; animation: pulse 1s infinite; }
        
        @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }
        
        .gesture-guide { display: flex; align-items: center; gap: 10px; margin-top: 8px; font-size: 0.85rem; color: #a5f3fc; }
    </style>
</head>
<body>

    <div id="canvas-container"></div>
    <video id="webcam-feed" autoplay playsinline muted></video>

    <div id="ui-layer">
        <div class="glass-card shadow-2xl">
            <h1 class="text-2xl font-black text-cyan-400 tracking-tighter mb-1">STAR CORE AI</h1>
            <div class="flex items-center mb-4">
                <span id="status-dot" class="status-dot loading"></span>
                <span id="status-text" class="text-xs font-mono text-gray-400">ƒêang kh·ªüi t·∫°o AI...</span>
            </div>

            <div class="space-y-3 border-t border-cyan-900/50 pt-4">
                <div class="gesture-guide"><span>‚òùÔ∏è</span> <b>Ch·ªâ tay:</b> N·ªï tung h·∫°t (Explode)</div>
                <div class="gesture-guide"><span>‚úä</span> <b>N·∫Øm tay:</b> Xoay v≈© tr·ª•</div>
                <div class="gesture-guide"><span>‚úåÔ∏è</span> <b>Hai ng√≥n:</b> Ph√≥ng to/Thu nh·ªè</div>
                <div class="gesture-guide"><span>üñê</span> <b>M·ªü tay:</b> Ch·∫ø ƒë·ªô ch·ªù</div>
            </div>

            <div class="mt-4 pt-3 border-t border-cyan-900/50">
                <p class="text-[10px] text-cyan-700 font-bold uppercase tracking-widest">H·ªá th·ªëng ph·∫£n h·ªìi:</p>
                <p id="debug-text" class="text-xs text-gray-500 font-mono mt-1">ƒêang qu√©t kh√¥ng gian...</p>
            </div>
        </div>
    </div>

    <script>
        // ==========================================
        // 1. KH·ªûI T·∫†O C·∫§U H√åNH THREE.JS
        // ==========================================
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.015);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 8;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const universeGroup = new THREE.Group();
        scene.add(universeGroup);

        const centralSystem = new THREE.Group();
        universeGroup.add(centralSystem);

        // T·∫°o Texture h·∫°t s·∫Øc n√©t
        const createSharpTexture = () => {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            grad.addColorStop(0, 'white');
            grad.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            grad.addColorStop(1, 'transparent');
            ctx.fillStyle = grad; ctx.fillRect(0, 0, 64, 64);
            const tex = new THREE.Texture(canvas); tex.needsUpdate = true;
            return tex;
        };
        const particleTexture = createSharpTexture();

        // ==========================================
        // 2. T·∫†O C√ÅC ƒê·ªêI T∆Ø·ª¢NG (H√†nh tinh, V√≤ng nh·∫´n, Sao)
        // ==========================================
        
        // --- B·ªÅ m·∫∑t h√†nh tinh (8000 h·∫°t) ---
        const surfCount = 8000;
        const surfGeo = new THREE.BufferGeometry();
        const surfPositions = new Float32Array(surfCount * 3);
        const surfOriginals = new Float32Array(surfCount * 3); // L∆∞u v·ªã tr√≠ g·ªëc ƒë·ªÉ thu h·ªìi sau khi n·ªï
        const surfColors = new Float32Array(surfCount * 3);

        for(let i=0; i<surfCount; i++) {
            const r = 1.8 + Math.random() * 0.5;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);
            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);
            
            surfPositions[i*3] = x; surfPositions[i*3+1] = y; surfPositions[i*3+2] = z;
            surfOriginals[i*3] = x; surfOriginals[i*3+1] = y; surfOriginals[i*3+2] = z;

            const color = new THREE.Color().setHSL(0.1 + Math.random()*0.1, 1, 0.5); // M√†u v√†ng cam
            surfColors[i*3] = color.r; surfColors[i*3+1] = color.g; surfColors[i*3+2] = color.b;
        }
        surfGeo.setAttribute('position', new THREE.BufferAttribute(surfPositions, 3));
        surfGeo.setAttribute('color', new THREE.BufferAttribute(surfColors, 3));
        const planetSurface = new THREE.Points(surfGeo, new THREE.PointsMaterial({ size: 0.07, vertexColors: true, map: particleTexture, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false }));
        centralSystem.add(planetSurface);

        // --- L√µi nƒÉng l∆∞·ª£ng xanh ---
        const coreCanvas = document.createElement('canvas'); coreCanvas.width=64; coreCanvas.height=64;
        const coreCtx = coreCanvas.getContext('2d');
        const coreGrad = coreCtx.createRadialGradient(32,32,0,32,32,32);
        coreGrad.addColorStop(0, '#fff'); coreGrad.addColorStop(0.3, '#0ff'); coreGrad.addColorStop(1, 'transparent');
        coreCtx.fillStyle = coreGrad; coreCtx.fillRect(0,0,64,64);
        const coreTex = new THREE.Texture(coreCanvas); coreTex.needsUpdate = true;
        const blueCore = new THREE.Sprite(new THREE.SpriteMaterial({ map: coreTex, blending: THREE.AdditiveBlending }));
        blueCore.scale.set(3,3,3);
        centralSystem.add(blueCore);

        // --- H√†m t·∫°o V√≤ng nh·∫´n ---
        function createRing(inner, outer, count, colorHex) {
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(count * 3);
            const orig = new Float32Array(count * 3);
            for(let i=0; i<count; i++) {
                const r = inner + Math.random() * (outer - inner);
                const a = Math.random() * Math.PI * 2;
                pos[i*3] = Math.cos(a) * r; pos[i*3+1] = (Math.random()-0.5)*0.1; pos[i*3+2] = Math.sin(a) * r;
                orig[i*3] = pos[i*3]; orig[i*3+1] = pos[i*3+1]; orig[i*3+2] = pos[i*3+2];
            }
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            const p = new THREE.Points(geo, new THREE.PointsMaterial({ size: 0.05, color: colorHex, map: particleTexture, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending }));
            p.userData.originalPositions = orig;
            return p;
        }
        const ring1 = createRing(3.2, 5.5, 10000, 0xffaa00);
        const ring2 = createRing(6.0, 6.8, 5000, 0x00ffff);
        centralSystem.add(ring1); centralSystem.add(ring2);

        // ==========================================
        // 3. LOGIC X·ª¨ L√ù TAY (MEDIAPIPE)
        // ==========================================
        let state = {
            detected: false,
            explode: 0, targetExplode: 0, // 0: B√¨nh th∆∞·ªùng, 1: N·ªï tung
            zoom: 8, targetZoom: 8,
            rotation: new THREE.Quaternion(),
            handX: 0, handY: 0, prevHandX: 0, prevHandY: 0
        };

        const debugText = document.getElementById('debug-text');
        const statusText = document.getElementById('status-text');
        const statusDot = document.getElementById('status-dot');

        function onResults(results) {
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                state.detected = false;
                state.targetExplode = 0; // T·ª± ƒë·ªông thu h·ªìi h·∫°t khi m·∫•t d·∫•u tay
                return;
            }
            state.detected = true;
            const lm = results.multiHandLandmarks[0];
            
            // L·∫•y t·ªça ƒë·ªô t√¢m b√†n tay
            state.handX = 1 - lm[9].x; state.handY = lm[9].y;

            // Ki·ªÉm tra c√°c ng√≥n tay g·∫≠p/m·ªü
            const isFolded = (tip, pip) => Math.hypot(lm[tip].x-lm[0].x, lm[tip].y-lm[0].y) < Math.hypot(lm[pip].x-lm[0].x, lm[pip].y-lm[0].y);
            const indexF = isFolded(8,6), middleF = isFolded(12,10), ringF = isFolded(16,14), pinkyF = isFolded(20,18);

            // PH√ÇN LO·∫†I C·ª¨ CH·ªà
            if (!indexF && middleF && ringF && pinkyF) {
                // 1. Ch·ªâ tay (‚òùÔ∏è) -> N·ªî TUNG
                state.targetExplode = 1;
                debugText.innerText = "K√çCH HO·∫†T: N·ªî TUNG H·∫†T";
            } 
            else if (indexF && middleF && ringF && pinkyF) {
                // 2. N·∫Øm tay (‚úä) -> XOAY
                state.targetExplode = 0;
                const dX = (state.handX - state.prevHandX) * 7;
                const dY = (state.handY - state.prevHandY) * 7;
                const qX = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), dY);
                const qY = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), dX);
                state.rotation.premultiply(qY).premultiply(qX);
                debugText.innerText = "ƒêANG XOAY H·ªÜ TH·ªêNG";
            }
            else if (!indexF && !middleF && ringF && pinkyF) {
                // 3. Hai ng√≥n (‚úåÔ∏è) -> ZOOM
                state.targetExplode = 0;
                const dist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                state.targetZoom = 15 - (dist * 25);
                debugText.innerText = "ƒêANG ƒêI·ªÄU CH·ªàNH KHO·∫¢NG C√ÅCH";
            }
            else {
                state.targetExplode = 0;
                debugText.innerText = "ƒêANG CH·ªú C·ª¨ CH·ªà...";
            }

            state.prevHandX = state.handX; state.prevHandY = state.handY;
        }

        // C√†i ƒë·∫∑t MediaPipe
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
        hands.onResults(onResults);

        const videoElement = document.getElementById('webcam-feed');
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 480, height: 360
        });
        cameraUtils.start().then(() => {
            statusText.innerText = "H·ªá th·ªëng ONLINE";
            statusDot.className = "status-dot active";
        });

        // ==========================================
        // 4. V√íNG L·∫∂P ANIMATION (X·ª¨ L√ù N·ªî & DI CHUY·ªÇN)
        // ==========================================
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            // M∆∞·ª£t h√≥a bi·∫øn n·ªï v√† zoom
            state.explode += (state.targetExplode - state.explode) * 0.1;
            camera.position.z += (state.targetZoom - camera.position.z) * 0.1;

            // Xoay nh·∫π t·ª± nhi√™n
            universeGroup.quaternion.slerp(state.rotation, 0.1);

            // HI·ªÜU ·ª®NG N·ªî: C·∫≠p nh·∫≠t v·ªã tr√≠ t·ª´ng h·∫°t
            // 1. Planet Surface
            const surfPosAttr = planetSurface.geometry.attributes.position;
            for(let i=0; i<surfCount; i++) {
                const i3 = i * 3;
                const ox = surfOriginals[i3], oy = surfOriginals[i3+1], oz = surfOriginals[i3+2];
                // H·∫°t bay ra xa t√¢m theo t·ªâ l·ªá n·ªï
                surfPosAttr.array[i3] = ox + ox * state.explode * 4;
                surfPosAttr.array[i3+1] = oy + oy * state.explode * 4;
                surfPosAttr.array[i3+2] = oz + oz * state.explode * 4;
            }
            surfPosAttr.needsUpdate = true;

            // 2. Rings
            [ring1, ring2].forEach(r => {
                const attr = r.geometry.attributes.position;
                const orig = r.userData.originalPositions;
                for(let i=0; i<attr.count; i++) {
                    const i3 = i * 3;
                    attr.array[i3] = orig[i3] + orig[i3] * state.explode * 2;
                    attr.array[i3+1] = orig[i3+1] + (Math.sin(time*2 + i)*0.5 * state.explode); // Th√™m ƒë·ªô rung khi n·ªï
                    attr.array[i3+2] = orig[i3+2] + orig[i3+2] * state.explode * 2;
                }
                attr.needsUpdate = true;
                r.rotation.y -= 0.005;
            });

            // Hi·ªáu ·ª©ng l√µi xanh ƒë·∫≠p (Pulse)
            const p = 1 + Math.sin(time * 4) * 0.1;
            blueCore.scale.set(3*p, 3*p, 3*p);
            blueCore.material.opacity = 0.5 + Math.sin(time*4)*0.5;

            planetSurface.rotation.y += 0.002;
            renderer.render(scene, camera);
        }

        // X·ª≠ l√Ω co gi√£n m√†n h√¨nh
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
