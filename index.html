/* --- SAO CH√âP V√Ä THAY TH·∫æ TO√ÄN B·ªò PH·∫¶N <script> TRONG FILE C·ª¶A B·∫†N --- */

// --- UI Logic ---
const toggleBtn = document.getElementById('toggle-ui-btn');
const uiLayer = document.getElementById('ui-layer');
toggleBtn.addEventListener('click', () => uiLayer.classList.toggle('hidden-ui'));

// --- 1. THREE.JS SETUP ---
const container = document.getElementById('canvas-container');
const debugText = document.getElementById('debug-text');

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000000, 0.02);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.z = 8;

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
container.appendChild(renderer.domElement);

const universeGroup = new THREE.Group();
scene.add(universeGroup);

const centralSystem = new THREE.Group();
universeGroup.add(centralSystem);

// --- TEXTURE GENERATION ---
const getSharpTexture = () => {
    const canvas = document.createElement('canvas');
    canvas.width = 64; canvas.height = 64;
    const ctx = canvas.getContext('2d');
    const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
    gradient.addColorStop(0, 'rgba(255,255,255,1)');
    gradient.addColorStop(0.3, 'rgba(255,255,255,0.4)');
    gradient.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 64, 64);
    const tex = new THREE.Texture(canvas);
    tex.needsUpdate = true;
    return tex;
};
const sharpTexture = getSharpTexture();

// --- STATE MANAGEMENT ---
let state = {
    isHandDetected: false,
    targetQuaternion: new THREE.Quaternion(),
    targetZoom: 8,
    explodeFactor: 0,   // 0 = B√¨nh th∆∞·ªùng, 1 = N·ªï tung
    targetExplode: 0,
    handX: 0, handY: 0,
    prevHandX: 0, prevHandY: 0,
    prevHandAngle: 0
};

// --- 1. THE PLANET SURFACE (C√≥ kh·∫£ nƒÉng n·ªï) ---
const surfaceParticleCount = 8000;
const surfGeo = new THREE.BufferGeometry();
const surfPos = new Float32Array(surfaceParticleCount * 3);
const surfOrigPos = new Float32Array(surfaceParticleCount * 3); // L∆∞u v·ªã tr√≠ g·ªëc
const surfCols = new Float32Array(surfaceParticleCount * 3);

for (let i = 0; i < surfaceParticleCount; i++) {
    const r = 1.9 + Math.random() * 0.4; 
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.acos((Math.random() * 2) - 1);

    const x = r * Math.sin(phi) * Math.cos(theta);
    const y = r * Math.sin(phi) * Math.sin(theta);
    const z = r * Math.cos(phi);

    surfPos[i*3] = x; surfPos[i*3+1] = y; surfPos[i*3+2] = z;
    surfOrigPos[i*3] = x; surfOrigPos[i*3+1] = y; surfOrigPos[i*3+2] = z;

    const col = new THREE.Color(0xffcc00).lerp(new THREE.Color(0xff5500), Math.random());
    surfCols[i*3] = col.r; surfCols[i*3+1] = col.g; surfCols[i*3+2] = col.b;
}
surfGeo.setAttribute('position', new THREE.BufferAttribute(surfPos, 3));
surfGeo.setAttribute('color', new THREE.BufferAttribute(surfCols, 3));
const planetSurface = new THREE.Points(surfGeo, new THREE.PointsMaterial({ size: 0.08, vertexColors: true, map: sharpTexture, blending: THREE.AdditiveBlending, transparent: true, opacity: 0.8, depthWrite: false }));
centralSystem.add(planetSurface);

// --- 2. PULSING CORE ---
const getBlueGlow = () => {
    const c = document.createElement('canvas'); c.width=64; c.height=64;
    const x = c.getContext('2d');
    const g = x.createRadialGradient(32,32,0,32,32,32);
    g.addColorStop(0, 'rgba(200, 255, 255, 1)');
    g.addColorStop(1, 'rgba(0, 0, 0, 0)');
    x.fillStyle = g; x.fillRect(0,0,64,64);
    const t = new THREE.Texture(c); t.needsUpdate=true; return t;
};
const blueCore = new THREE.Sprite(new THREE.SpriteMaterial({ map: getBlueGlow(), color: 0x00ffff, blending: THREE.AdditiveBlending }));
blueCore.scale.set(3, 3, 3);
centralSystem.add(blueCore);

// --- 3. RINGS (C√≥ kh·∫£ nƒÉng n·ªï) ---
const createRing = (innerR, outerR, count, colorHex) => {
    const geo = new THREE.BufferGeometry();
    const pos = new Float32Array(count * 3);
    const origPos = new Float32Array(count * 3);
    for(let i=0; i<count; i++) {
        const r = innerR + Math.random() * (outerR - innerR);
        const theta = Math.random() * Math.PI * 2;
        pos[i*3] = r * Math.cos(theta);
        pos[i*3+1] = (Math.random()-0.5)*0.1;
        pos[i*3+2] = r * Math.sin(theta);
        origPos[i*3] = pos[i*3]; origPos[i*3+1] = pos[i*3+1]; origPos[i*3+2] = pos[i*3+2];
    }
    geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    const points = new THREE.Points(geo, new THREE.PointsMaterial({ size: 0.05, color: colorHex, map: sharpTexture, blending: THREE.AdditiveBlending, transparent: true, opacity: 0.6 }));
    points.userData.origPos = origPos; // L∆∞u tr·ªØ ƒë·ªÉ n·ªï
    return points;
};
const mainRing = createRing(3.2, 6.0, 10000, 0xffaa00);
centralSystem.add(mainRing);

// --- GESTURE LOGIC ---
function onResults(results) {
    if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
        state.isHandDetected = false;
        state.targetExplode = 0; // T·ª± ƒë·ªông thu h·ªìi khi m·∫•t tay
        return;
    }
    state.isHandDetected = true;
    const lm = results.multiHandLandmarks[0];
    state.handX = 1 - lm[9].x; state.handY = lm[9].y;

    const isFolded = (tip, pip) => Math.hypot(lm[tip].x-lm[0].x, lm[tip].y-lm[0].y) < Math.hypot(lm[pip].x-lm[0].x, lm[pip].y-lm[0].y);
    const indexF = isFolded(8,6);
    const middleF = isFolded(12,10);
    const ringF = isFolded(16,14);
    const pinkyF = isFolded(20,18);

    // C·ª¨ CH·ªà M·ªöI: CH·ªà NG√ìN TR·ªé = N·ªî TUNG
    const isPointing = !indexF && middleF && ringF && pinkyF;
    const isFist = indexF && middleF && ringF && pinkyF;
    const isTwoFingers = !indexF && !middleF && ringF && pinkyF;

    if (isPointing) {
        state.targetExplode = 1;
        debugText.innerText = "‚òùÔ∏è EXPLODING PARTICLES";
    } else if (isFist) {
        state.targetExplode = 0;
        debugText.innerText = "‚úä ROTATING";
        const dX = state.handX - state.prevHandX;
        const dY = state.handY - state.prevHandY;
        const qY = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), dX * 6);
        const qX = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), dY * 6);
        state.targetQuaternion.premultiply(qY).premultiply(qX);
    } else if (isTwoFingers) {
        state.targetExplode = 0;
        const dist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
        state.targetZoom = 15 - (dist * 25);
    } else {
        state.targetExplode = 0;
        debugText.innerText = "üñê READY (Open Hand)";
    }

    state.prevHandX = state.handX; state.prevHandY = state.handY;
    const dx = lm[9].x - lm[0].x; const dy = lm[9].y - lm[0].y;
    state.prevHandAngle = Math.atan2(dy, dx);
}

// --- ANIMATION LOOP (Ph·∫ßn quan tr·ªçng nh·∫•t) ---
let time = 0;
function animate() {
    requestAnimationFrame(animate);
    time += 0.015;

    // 1. N·ªôi suy Explode Factor (m∆∞·ª£t m√†)
    state.explodeFactor += (state.targetExplode - state.explodeFactor) * 0.08;

    // 2. C·∫≠p nh·∫≠t v·ªã tr√≠ h·∫°t Planet Surface
    const surfAttr = planetSurface.geometry.attributes.position;
    for (let i = 0; i < surfaceParticleCount; i++) {
        const i3 = i * 3;
        // H∆∞·ªõng n·ªï = Vector t·ª´ t√¢m ƒë·∫øn v·ªã tr√≠ g·ªëc
        const ox = surfOrigPos[i3], oy = surfOrigPos[i3+1], oz = surfOrigPos[i3+2];
        
        // V·ªã tr√≠ n·ªï = V·ªã tr√≠ g·ªëc * h·ªá s·ªë n·ªï
        surfAttr.array[i3] = ox + ox * state.explodeFactor * 3;
        surfAttr.array[i3+1] = oy + oy * state.explodeFactor * 3;
        surfAttr.array[i3+2] = oz + oz * state.explodeFactor * 3;
    }
    surfAttr.needsUpdate = true;

    // 3. C·∫≠p nh·∫≠t v·ªã tr√≠ h·∫°t Ring
    const ringAttr = mainRing.geometry.attributes.position;
    const ringOrig = mainRing.userData.origPos;
    for (let i = 0; i < ringAttr.count; i++) {
        const i3 = i * 3;
        const ox = ringOrig[i3], oy = ringOrig[i3+1], oz = ringOrig[i3+2];
        ringAttr.array[i3] = ox + ox * state.explodeFactor * 2;
        ringAttr.array[i3+1] = oy + (Math.sin(time + i) * state.explodeFactor * 2); // Th√™m ch√∫t nhi·ªÖu s√≥ng khi n·ªï
        ringAttr.array[i3+2] = oz + oz * state.explodeFactor * 2;
    }
    ringAttr.needsUpdate = true;

    // 4. Camera & Core Animation
    camera.position.z += (state.targetZoom - camera.position.z) * 0.05;
    universeGroup.quaternion.slerp(state.targetQuaternion, 0.1);
    
    const pulse = 1 + Math.sin(time * 3) * 0.1;
    blueCore.scale.set(3 * pulse, 3 * pulse, 3 * pulse);
    
    // Xoay nh·∫π t·ª± nhi√™n
    planetSurface.rotation.y -= 0.002;
    mainRing.rotation.y -= 0.004;

    renderer.render(scene, camera);
}

// Kh·ªüi t·∫°o MediaPipe & Camera
const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
hands.onResults(onResults);
new Camera(videoElement, { onFrame: async () => await hands.send({image: videoElement}), width: 320, height: 240 }).start();

animate();
